// Content script for Notion pages
console.log('Notion to Nanobanana Pro: Content script loaded');

let floatingButton = null;
let selectedBlock = null;

// Create floating button for image generation
function createFloatingButton() {
  if (floatingButton) return;

  floatingButton = document.createElement('div');
  floatingButton.id = 'nanobanana-generate-btn';
  floatingButton.innerHTML = `
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z" fill="currentColor"/>
    </svg>
    <span>Generate Image</span>
  `;
  floatingButton.style.display = 'none';
  document.body.appendChild(floatingButton);

  floatingButton.addEventListener('click', handleGenerateImage);
}

// Get text content from Notion block
function getBlockContent(element) {
  // Try to find the text content in various Notion block structures
  const textElement = element.querySelector('[data-content-editable-leaf="true"]') ||
                      element.querySelector('[contenteditable="true"]') ||
                      element.querySelector('.notion-text-block') ||
                      element;

  return textElement.innerText || textElement.textContent || '';
}

// Get block ID from Notion block element
function getBlockId(element) {
  // Notion blocks have data-block-id attribute
  let blockElement = element.closest('[data-block-id]');
  if (blockElement) {
    return blockElement.getAttribute('data-block-id');
  }
  return null;
}

// Handle block selection
function handleBlockSelection() {
  const selection = window.getSelection();

  if (selection.rangeCount > 0) {
    const range = selection.getRangeAt(0);
    const container = range.commonAncestorContainer;
    const blockElement = container.nodeType === 3
      ? container.parentElement.closest('[data-block-id]')
      : container.closest('[data-block-id]');

    if (blockElement) {
      selectedBlock = {
        element: blockElement,
        content: getBlockContent(blockElement),
        blockId: getBlockId(blockElement)
      };

      // Show floating button near selection
      if (selectedBlock.content.trim()) {
        showFloatingButton(range);
      }
    }
  }
}

// Show floating button near the selection
function showFloatingButton(range) {
  if (!floatingButton) createFloatingButton();

  const rect = range.getBoundingClientRect();
  floatingButton.style.display = 'flex';
  floatingButton.style.top = `${rect.bottom + window.scrollY + 10}px`;
  floatingButton.style.left = `${rect.left + window.scrollX}px`;
}

// Hide floating button
function hideFloatingButton() {
  if (floatingButton) {
    floatingButton.style.display = 'none';
  }
  selectedBlock = null;
}

// Handle image generation
async function handleGenerateImage() {
  if (!selectedBlock || !selectedBlock.content.trim()) {
    showNotification('Please select a block with text content', 'error');
    return;
  }

  hideFloatingButton();

  // Show prompt selection modal
  const prompt = await showPromptModal(selectedBlock.content);

  if (!prompt) {
    // User cancelled
    return;
  }

  showNotification('Generating image...', 'info');

  try {
    // Send message to background script to generate image
    const response = await chrome.runtime.sendMessage({
      action: 'generateImage',
      prompt: prompt
    });

    if (response.success && response.imageUrl) {
      // Insert image directly into Notion DOM
      insertImageIntoNotion(response.imageUrl, selectedBlock.element);
      showNotification('Image generated and added!', 'success');
    } else {
      showNotification(`Error: ${response.error}`, 'error');
    }
  } catch (error) {
    console.error('Error generating image:', error);
    showNotification(`Error: ${error.message}`, 'error');
  }
}

// Insert image into Notion page by manipulating DOM
function insertImageIntoNotion(imageUrl, afterBlock) {
  try {
    // Create a new image block
    const imageBlock = document.createElement('div');
    imageBlock.className = 'notion-image-block';
    imageBlock.setAttribute('data-block-id', generateUUID());
    imageBlock.style.cssText = `
      width: 100%;
      max-width: 100%;
      margin: 4px 0;
      padding: 3px 2px;
    `;

    // Create image wrapper
    const imageWrapper = document.createElement('div');
    imageWrapper.style.cssText = `
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    `;

    // Create image element
    const img = document.createElement('img');
    img.src = imageUrl;
    img.alt = 'Generated by Nanobanana Pro';
    img.style.cssText = `
      max-width: 100%;
      height: auto;
      border-radius: 3px;
      box-shadow: rgba(15, 15, 15, 0.1) 0px 0px 0px 1px, rgba(15, 15, 15, 0.1) 0px 2px 4px;
    `;

    // Add loading handler
    img.onload = () => {
      console.log('Image loaded successfully');
    };

    img.onerror = () => {
      showNotification('Failed to load generated image', 'error');
    };

    // Assemble the structure
    imageWrapper.appendChild(img);
    imageBlock.appendChild(imageWrapper);

    // Insert after the selected block
    if (afterBlock && afterBlock.parentNode) {
      afterBlock.parentNode.insertBefore(imageBlock, afterBlock.nextSibling);
    } else {
      // Fallback: append to the page content
      const pageContent = document.querySelector('[data-block-id]')?.parentNode;
      if (pageContent) {
        pageContent.appendChild(imageBlock);
      }
    }

    console.log('Image inserted into Notion page');
  } catch (error) {
    console.error('Error inserting image:', error);
    showNotification('Failed to insert image into page', 'error');
  }
}

// Generate a UUID for the new block
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// Show prompt selection modal
async function showPromptModal(selectedText) {
  return new Promise(async (resolve) => {
    // Get presets from storage
    const { presets = [] } = await chrome.storage.sync.get(['presets']);

    // Create modal overlay
    const overlay = document.createElement('div');
    overlay.id = 'nanobanana-prompt-modal-overlay';
    overlay.className = 'nanobanana-modal-overlay';

    // Create modal
    const modal = document.createElement('div');
    modal.className = 'nanobanana-modal';
    modal.innerHTML = `
      <div class="nanobanana-modal-header">
        <h3>プロンプトを選択 (Select Prompt)</h3>
        <button class="nanobanana-modal-close" title="Close">✕</button>
      </div>
      <div class="nanobanana-modal-body">
        <div class="nanobanana-prompt-option">
          <input type="radio" id="prompt-selected-text" name="prompt-type" value="selected" checked>
          <label for="prompt-selected-text">
            <strong>選択したテキストを使用 (Use selected text)</strong>
            <div class="prompt-preview">${escapeHtml(selectedText)}</div>
          </label>
        </div>

        ${presets.length > 0 ? `
          <div class="nanobanana-prompt-option">
            <input type="radio" id="prompt-preset" name="prompt-type" value="preset">
            <label for="prompt-preset">
              <strong>プリセットを使用 (Use preset)</strong>
            </label>
            <select id="preset-selector" class="nanobanana-select" disabled>
              ${presets.map((p, i) => `<option value="${i}">${escapeHtml(p.name)}</option>`).join('')}
            </select>
          </div>
        ` : ''}

        <div class="nanobanana-prompt-option">
          <input type="radio" id="prompt-custom" name="prompt-type" value="custom">
          <label for="prompt-custom">
            <strong>カスタムプロンプト (Custom prompt)</strong>
          </label>
          <textarea id="custom-prompt-input" class="nanobanana-textarea" rows="4" placeholder="Enter your custom prompt..." disabled></textarea>
        </div>
      </div>
      <div class="nanobanana-modal-footer">
        <button class="nanobanana-btn nanobanana-btn-secondary" id="modal-cancel">キャンセル (Cancel)</button>
        <button class="nanobanana-btn nanobanana-btn-primary" id="modal-generate">生成 (Generate)</button>
      </div>
    `;

    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    // Setup event listeners
    const closeBtn = modal.querySelector('.nanobanana-modal-close');
    const cancelBtn = modal.querySelector('#modal-cancel');
    const generateBtn = modal.querySelector('#modal-generate');
    const radioButtons = modal.querySelectorAll('input[name="prompt-type"]');
    const presetSelector = modal.querySelector('#preset-selector');
    const customInput = modal.querySelector('#custom-prompt-input');

    // Enable/disable inputs based on radio selection
    radioButtons.forEach(radio => {
      radio.addEventListener('change', () => {
        if (presetSelector) {
          presetSelector.disabled = radio.value !== 'preset';
        }
        if (customInput) {
          customInput.disabled = radio.value !== 'custom';
        }
      });
    });

    // Close modal
    const closeModal = () => {
      overlay.remove();
      resolve(null);
    };

    closeBtn.addEventListener('click', closeModal);
    cancelBtn.addEventListener('click', closeModal);
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) closeModal();
    });

    // Generate button
    generateBtn.addEventListener('click', () => {
      const selectedType = modal.querySelector('input[name="prompt-type"]:checked').value;
      let finalPrompt = '';

      if (selectedType === 'selected') {
        finalPrompt = selectedText;
      } else if (selectedType === 'preset' && presetSelector) {
        const presetIndex = parseInt(presetSelector.value);
        const preset = presets[presetIndex];
        // Replace {text} with selected text
        finalPrompt = preset.prompt.replace(/\{text\}/g, selectedText);
      } else if (selectedType === 'custom' && customInput) {
        finalPrompt = customInput.value.trim();
        if (!finalPrompt) {
          showNotification('カスタムプロンプトを入力してください (Please enter custom prompt)', 'error');
          return;
        }
      }

      overlay.remove();
      resolve(finalPrompt);
    });

    // Focus on modal
    setTimeout(() => overlay.classList.add('show'), 10);
  });
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Show notification
function showNotification(message, type = 'info') {
  const notification = document.createElement('div');
  notification.className = `nanobanana-notification nanobanana-notification-${type}`;
  notification.textContent = message;
  document.body.appendChild(notification);

  setTimeout(() => {
    notification.classList.add('show');
  }, 10);

  setTimeout(() => {
    notification.classList.remove('show');
    setTimeout(() => notification.remove(), 300);
  }, 3000);
}

// Initialize
function init() {
  createFloatingButton();

  // Listen for text selection
  document.addEventListener('mouseup', handleBlockSelection);
  document.addEventListener('keyup', (e) => {
    if (e.key === 'Escape') {
      hideFloatingButton();
    }
  });

  // Hide button when clicking elsewhere
  document.addEventListener('mousedown', (e) => {
    if (floatingButton && !floatingButton.contains(e.target)) {
      const selection = window.getSelection();
      if (!selection.toString()) {
        hideFloatingButton();
      }
    }
  });
}

// Wait for page to load
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
